# Parameters
nc: 80 # number of classes
scales: # model compound scaling constants, i.e. 'model=yolov8n.yaml' will call yolov8.yaml with scale 'n'
  # [depth, width, max_channels]
  n: [0.33, 0.25, 1024] # YOLOv8n summary: 129 layers, 3157200 parameters, 3157184 gradients, 8.9 GFLOPS
  s: [0.33, 0.50, 1024] # YOLOv8s summary: 129 layers, 11166560 parameters, 11166544 gradients, 28.8 GFLOPS

# YOLOv8.0n backbone
backbone:
  # input -> 640×640×3
  # [from, repeats, module, args]
  - [-1, 1, Conv, [64, 3, 2]] # 0-P1/2             320×320×64
  - [-1, 1, Conv, [128, 3, 2]] # 1-P2/4            160×160×128
  - [-1, 3, C2f, [128, True]]  # 2                 160×160×128
  - [-1, 1, Conv, [256, 3, 2]] # 3-P3/8            80×80×256
  - [-1, 6, C2fBRA, [256, True]]  # 4                 80×80×256
  - [-1, 1, Conv, [512, 3, 2]] # 5-P4/16           40×40×512
  - [-1, 6, C2fBRA, [512, True]]  #  6                40×40×512
  - [-1, 1, Conv, [1024, 3, 2]] # 7-P5/32          20×20×1024
  - [-1, 3, C2fBRA, [1024, True]]  # 8                20×20×1024
  - [-1, 1, SPPF, [1024, 5]] # 9                   20×20×1024

# LUD-YOLO head with ASFF3 fusion
head:
  # 第一步：SPPF后上采样到P4并与backbone P4拼接
  - [-1, 1, nn.Upsample, [None, 2, "nearest"]] #   40×40×1024
  - [[-1, 6], 1, Concat, [1]] # cat backbone P4    40×40×(1024+512) = 40×40×1536
  - [-1, 3, C2fBRA, [512]] # 12                       40×40×512

  # 第二步：ASFF3融合模块 - 直接使用backbone的P2(1), P3(4), P4(6)
  - [[1, 4, 12], 1, ASFF3, [0]] # ASFF3输出P2融合特征

  # 第三步：从ASFF3的P2融合特征开始，经过两次变化生成三个预测分支
  # 分支1：P2 -> P3 (下采样)
  - [-1, 1, Conv, [128, 3, 2]] # 14                  80×80×128
  - [-1, 1, C2fBRA, [256, True]]
  - [[-1, 4], 1, Concat, [1]] # cat with backbone P3       80×80×(256+256) = 80×80×512
  - [-1, 1, Conv, [256, 3, 1]] # 17 预测头1           80×80×256

  # 分支2：P2 -> P3 -> P4 (两次下采样)
  - [-1, 1, Conv, [256, 3, 2]] # 18                  40×40×256
  - [-1, 1, C2fBRA, [512, True]]
  - [[-1, 12], 1, Concat, [1]] # cat with fused P4       40×40×(512+512) = 40×40×1024
  - [-1, 1, Conv, [512, 3, 1]] # 21 预测头2           40×40×512

  # 分支3：P2 -> P3 -> P4 -> P5 (三次下采样)
  - [-1, 1, Conv, [512, 3, 2]] # 22                  20×20×512
  - [-1, 1, C2fBRA, [1024, True]]
  - [[-1, 9], 1, Concat, [1]] # cat with SPPF      20×20×(1024+1024) = 20×20×2048
  - [-1, 1, Conv, [1024, 3, 1]] # 25 预测头3          20×20×1024

  # 检测头：使用三个预测分支的输出
  - [[17, 21, 25], 1, Detect, [nc]] # Detect(P2_pred, P3_pred, P4_pred)